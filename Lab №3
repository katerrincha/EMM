
##----------------------№3. AR(p)ARCH(q) и реальные данные --------------------------


# 1. Реализовать 𝐴𝑅(2)𝐴𝑅𝐶𝐻(3) процесс из 𝑛 = 2100 наблюдений с значениями 
# параметров 𝜃 = (−0.3, 0.4)′, 𝐴 = (1, 0.2, 0.1, 0.2)′ и построить его график.

n = 2100
AR_2_ARCH_3 = function(a, theta) 
{
  x = array(n)
  sigma = array(n)
  e = rnorm(n, 0, 1)
  
  sigma[1] = a[1]
  x[1] = sqrt(sigma[1])*e[1]
  sigma[2] = a[1] + a[2]*x[1]^2 
  x[2] = theta[1]*x[1] + sqrt(sigma[2])*e[2]
  sigma[3] = a[1] + a[2]*x[2]^2 + a[3]*x[1]^2
  x[3] = theta[1]*x[2] + theta[2]*x[1] + sqrt(sigma[3])*e[3]
  
  for (i in 4:n) 
  {
    sigma[i] = a[1] + a[2]*x[i-1]^2 + a[3]*x[i-2]^2 + a[4]*x[i-3]^2
    x[i] = theta[1]*x[i-1] + theta[2]*x[i-2] + sqrt(sigma[i])*e[i]
  }
  plot(x, type = 'l', main = "𝐴𝑅(2)𝐴𝑅𝐶𝐻(3) процесс:")
  x
}
theta = c(-0.3, 0.4)
A = c(1, 0.2, 0.1, 0.2)
x_2_3 = AR_2_ARCH_3(A, theta)


# 2. Разделить, полученную на первом шаге последовательность {𝑥𝑛}, в отношении 
# 20 : 1 на обучающую и тестовую выборки соответственно.
# 3. На основе обучающей выборки получить оценки параметров 𝜃 = (𝜃1, 𝜃2)′ и 
#𝐴 = (𝑎0, 𝑎1, 𝑎2, 𝑎3)′

n = 2100
n2 = 2000
n3 = 100
x_ob = x_2_3[1 : n2] # делим последовательность {𝑥𝑛} на обучающую и тестовую выборки 
# в отношении 20:1 (2000/100)
x_test = x_2_3[2001 : n]

a = arima(x_ob, order = c(2, 0, 0), include.mean = FALSE) # для оценивания 𝜃 используем функцию 𝑎𝑟𝑖𝑚𝑎()
theta1 = c(a$coef[1], a$coef[2]); theta1

library("tseries")
h = array(2000)
h[1] = x_ob[1]
h[2] = x_ob[2] - theta1[1]*x_ob[1]
for (i in 3 : n2)
{
  h[i] = x_ob[i] - theta1[1]*x_ob[i-1] - theta1[2]*x_ob[i-2]
}
g = garch(h, order = c(3, 0), start = A) # для оценивания вектора 𝐴 используем функцию 𝑔𝑎𝑟𝑐ℎ() по невязкам {ℎˆ𝑛}
A1 = c(g$coef[1], g$coef[2], g$coef[3], g$coef[4]); A1


# 4. Построить последовательность прогнозов на один шаг на тестовой выборке. 
# Наложить последовательность прогнозов на последовательность наблюдений процесса. 

plot(x_test, type = 'l', col = 'lightblue', main = "Наложение посл-ти прогнозов на посл-ть наблюдений процесса:")
f = function(x_test, theta, a) 
{
  x1 = array(n3) # последовательность прогнозов на 1 шаг {𝑥𝑛+1|𝑛}
  sigma = array(n3)
  gr1 = array(n3) # верхняя и нижняя границы прогноза волатильности процесса
  gr2 = array(n3)
  x1[1] = 0
  x1[2] = theta[1]*x_test[1]
  x1[3] = theta[1]*x_test[2] + theta[2]*x_test[1]
  sigma[1] = a[1]
  sigma[2] = a[1] + a[2]*x_test[1]^2
  sigma[3] = a[1] + a[2]*x_test[2]^2 + a[3]*x_test[1]^2
  for(i in 4 : n3) 
  {
    x1[i] = theta[1]*x_test[i-1] + theta[2]*x_test[i-2]
    sigma[i] = a[1] + a[2]*x_test[i-1]^2 + a[3]*x_test[i-2]^2 + a[4]*x_test[i-3]^2
  } 
  for(i in 1 : n3) # рассчет границ
  {
    gr1[i] = x1[i] + sqrt(sigma[i])
    gr2[i] = x1[i] - sqrt(sigma[i])
  }
  
  # последовательность прогнозов на один шаг на тестовой выборке и наложение
  # посл-ти прогнозов на последовательность наблюдений процесса:
  lines(x1, type = 'p', col = 'black') 
  lines(gr1, lty = 2, col = 'red')
  lines(gr2, lty = 2, col = 'red')
}
f(x_test, theta1, A1)


# 5. Скачать любые дневные котировки финансовых активов или значения индексов (минимум за 3 года).
# 6. Импортировать скачанные данные в 𝑅, используя функцию 𝑟𝑒𝑎𝑑.𝑡𝑎𝑏𝑙𝑒();
# 7. Построить график динамики актива;

table = read.table(file = 'D:/УНИВЕР!/4 курс/ЭММ/table1.txt', header = TRUE) # данные Индекс РТС за последние три года
print(table)
nrow(table)
act = table$OPEN # рассматриваем столбец с величиной индекса 
act
plot(act, type = 'l', main = "График динамики актива:") 

# 8. Привести данные к стационарному виду, используя одно из преобразований
#𝑧𝑘 =  (𝑃𝑘 − 𝑃𝑘−1) /𝑃𝑘−1, или 𝑧𝑘 = ln 𝑃𝑘/𝑃𝑘−1, 𝑘 ≥ 1,
# где 𝑃𝑘 – значение финансового актива в момент времени 𝑘, 𝑧𝑘 – доходность
# финансового актива в момент времени 𝑘;
# 9. Построить график доходностей {𝑧𝑘} финансового актива;

z = array(nrow(table))
z[1] = 0
for(k in 2 : nrow(table))
  z[k] = log(act[k]/act[k - 1])
plot(z, type = 'l', main = "График доходностей {𝑧𝑘} финансового актива:")

# 10. Повторить шаги 2-4 для последовательности {𝑧𝑛} при предположении, что процесс 
# {𝑧𝑛} описывается моделью 𝐴𝑅(2)𝐴𝑅𝐶𝐻(3).

n = nrow(table)
n
n2 = 6353
n3 = 317
x2_ob = z[1 : n2] #  nrow(table) = 6670, делим последовательность {𝑥𝑛} на обучающую 
# и тестовую выборки в отношении 20:1 (6353/317)
x2_test = z[6354 : n]

a2 = arima(x2_ob, order = c(2, 0, 0), include.mean = FALSE) # для оценивания 𝜃 используем функцию 𝑎𝑟𝑖𝑚𝑎()
theta2 = c(a2$coef[1], a2$coef[2]); theta2

h2 = array(n2)
h2[1] = x2_ob[1]
h2[2] = x2_ob[2] - theta2[1]*x2_ob[1]
for (i in 3 : n2)
{
  h2[i] = x2_ob[i] - theta2[1]*x2_ob[i-1] - theta2[2]*x2_ob[i-2]
}
g2 = garch(h2, order = c(3, 0)) # для оценивания вектора 𝐴 используем функцию 𝑔𝑎𝑟𝑐ℎ() по невязкам {ℎˆ𝑛}
A2 = c(g2$coef[1], g2$coef[2], g2$coef[3], g2$coef[4]); A2

plot(x2_test, type = 'l', col = 'lightblue', main = "Наложение посл-ти прогнозов на посл-ть наблюдений процесса")
f(x2_test, theta2, A2)
