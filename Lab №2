
##-------------------------------- №2. GARCH(p, q) -----------------------------------

install.packages("tseries")
library("tseries")

# 1. Построить график стационарного процесса {ℎ𝑛} и график волатильности
# {𝜎𝑛} процесса 𝐺𝐴𝑅𝐶𝐻(1,0), из 𝑛 = 1000 наблюдений

n = 1000
a0 = 0.9
a1 = 0.3 # Стационарность достигается при 0 < 𝑎1 < 1

GARCH_1_0 = function(a0, a1) 
{
  e = rnorm(n, 0, 1)
  h = array(n)
  h[1] = 0
  sigma = array(n)
  sigma[1] = 1
  
  for (i in 2 : n) 
  {
    sigma[i] = a0 + a1*(h[i-1])^2
    h[i] = sqrt(sigma[i])*e[i]
  }
  
  plot(h, type = 'l', main = "График стационарного процесса {ℎ𝑛} 𝐺𝐴𝑅𝐶𝐻(1,0)", col = "grey")
  plot(sigma, type = 'l', main = "График волатильности {𝜎𝑛}", col = "purple")
  h
}
h = GARCH_1_0(a0, a1)

# 2. Оценить параметры 𝑎0 и 𝑎1 с помощью метода наименьших квадратов
#(МНК), путем преобразования процесса 𝐴𝑅𝐶𝐻(1) ≡ 𝐺𝐴𝑅𝐶𝐻(1, 0) к
#процессу авторегрессии первого порядка.

MNK1 = function(h)
{
  x1 = x2 = y1 = y2 = 0
  for (i in 2 : n) 
  {
    x1 = x1 + h[i-1]^2
    y1 = y1 + h[i]^2
    x2 = x2 + h[i-1]^4
    y2 = y2 + h[i-1]^2 * h[i]^2
  }
  (y2/n - x1*y1/(n^2))/(x2/n - (x1/n)^2)
}
mnk_a1 = MNK1(h)

MNK0 = function(h, a)
{
  x1 = y1 = 0
  for (i in 2 : n) 
  {
    x1 = x1 + h[i-1]^2
    y1 = y1 + h[i]^2
  }
  y1/n - a*x1/n
}
mnk_a0 = MNK0(h, mnk_a1)
mnk_a0
mnk_a1


# 3. Оценить параметры 𝑎0, 𝑎1 при помощи функции 𝑔𝑎𝑟𝑐ℎ() пакета 
#tseries по выборке {ℎ𝑛}.

garch(h, order = c(1, 0), start = c(a0, a1))


# 4. Построить график стационарного процесса 𝐺𝐴𝑅𝐶𝐻(3,0), из 𝑛 = 1100
#наблюдений. Разделить процесс на обучающую и тестовую выборки в отношении 10:1. 
#Оценить вектор параметров (𝑎0, 𝑎1, 𝑎2, 𝑎3)′ на обучающей выборке, 
#используя функцию 𝑔𝑎𝑟𝑐ℎ(). Затем вычислить последовательность прогнозов 
#на 1 шаг {ℎ𝑛+1|𝑛} на тестовой выборке и наложить прогнозы на график процесса.

n = 1100

GARCH_3_0 = function(a) 
{
  e = rnorm(n, 0, 1)
  h = array(n)
  h[1] = 0
  sigma = array(n)
  
  sigma[2] = a[1]
  h[2] = sqrt(sigma[2])*e[1]
  sigma[3] = a[1] + a[2]*(h[2]^2) + a[3]*(h[1]^2)
  h[3] = sqrt(sigma[3])*e[2]
  sigma[4] = a[1] + a[2]*(h[3]^2) + a[3]*(h[2]^2) + a[4]*(h[1]^2)
  h[4] = sqrt(sigma[4])*e[3]
  
  for (i in 4 : n) 
  {
    sigma[i] = a[1] + a[2]*(h[i-1]^2) + a[3]*(h[i-2]^2) + a[4]*(h[i-3]^2)
    h[i] = sqrt(sigma[i])*e[i]
  }
  plot(h, type = 'l', main = "График стационарного процесса 𝐺𝐴𝑅𝐶𝐻(3,0)")
  h
}

a = c(0.2, 0.1, 0.5, 0.1) # задаем вектор параметров а: стационарность достигается при  0 < ∑ai < 1
h2 = GARCH_3_0(a)

n = 1100
n3 = 1000
n4 = 100
h_ob = h2[1 : n3] # делим процесс на обучающую и тестовую выборки в отношении 10:1 (1000/100)
a2 = garch(h_ob, order = c(3, 0), start = a)$coef # оценка вектора параметров а на обучающей выборке
a2 # оценка близка

h_test = h2[1001 : n]

f = function(h_test, h_ob, a) 
{
  h = array(100)
  h_new = array(1100)
  
  h[1] = a[1]
  h[2] = a[1] + a[2]*(h_test[1]^2)
  h[3] = a[1] + a[2]*(h_test[2]^2) + a[3]*(h_test[1]^2)
  
  for(i in 4 : 100) 
  {
    h[i] = a[1] + a[2]*(h_test[i-1]^2) + a[3]*(h_test[i-2]^2) + a[4]*(h_test[i-3]^2)
  }
  
  for(i in 1 : 1000)
    h_new[i] = h_ob[i]
  for(i in 1001 : 1100)
    h_new[i] = h[i - 1000] # добавляю значения прогноза
  h_new
}

h3 = f(h_test, h_ob, a2)
lines(h3, type = 'l', col = "purple") # прогнозы на графике процесса 


# 5. Построить стационарный процесс 𝐺𝐴𝑅𝐶𝐻(1,1), из 𝑛 = 1000 наблюдений
#и оценить его параметры (𝑎0, 𝑎1, 𝑏1)′ по выборке {ℎ𝑛}, используя функцию 
#𝑔𝑎𝑟𝑐ℎ().

n = 1000

GARCH_1_1 = function(a0, a1, b1) 
{
  e = rnorm(n, 0, 1)
  h = array(n)
  h[1] = 1
  sigma = array(n)
  sigma[1] = 1
  
  for (i in 2 : n) 
  {
    sigma[i] = a0 + a1*(h[i-1])^2 + b1*sigma[i-1]
    h[i] = sqrt(sigma[i])*e[i]
  }
  h
}

a0 = 1
a1 = 0.5
b1 = 0.3 # cтационарность достигается при 0 < 𝑎1 + 𝑏1 < 1.

h4 = GARCH_1_1(a0, a1, b1)
garch(h4, order = c(1, 1), start = c(a0, a1, b1)) # оценка параметров


